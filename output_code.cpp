                                  namespace                        dybi{                   class                            dynamic_bitset                                                    {public                             :constexpr                              static        int                        B       = 64; class   
                                    bit_reference                      {                   dynamic_bitset                           &                                                      bitset_ref         ;int       pos;public                                             :bit_reference                     (     dynamic_bitset  
                                    &ref                     ,     int  p)                :         bitset_ref              (      ref                                               ) ,pos               (p){}     bit_reference    &   operator                                    =( bool                       val                 ) 
                                    {                            bitset_ref               .         set                     (     pos                                              , val               );return    *this              ;}bit_reference                                  &    operator               =             (const  
                                    bit_reference                     &   other           )         {                     bitset_ref                                              .set             (pos       ,static_cast         <bool       >                                        (   other  ))             ; return     *  this;} 
                                    operator                          bool()          const         {                     return   bitset_ref                                  .get            ( pos         );}                        bit_reference&                   flip(){         bitset_ref  .set         (                      
                                      pos                              ,! bitset_ref      .                               get      (                                         pos)       );   return *    this                     ; }bool    operator                           ~()const { return     !bitset_ref .                      
                                      get                               (  pos            )        ;                       }       }                                  ;    static_assert         (     sizeof                               (uint64_t                                           )*8   ==B,"check block width"       );   
                                      /*             */                 static_assert     (                              std       ::                                 is_same        <uint64_t,   uint64_t                                 /*      */                              >::     value   /*j    */      ,                      
                                     "modify popcnt(), ctz(), clz()"     )   ;static      inline                           constexpr                                  bool         on      (    int                                        i, uint64_t                        x)noexcept                {  return (                    ( 
                                       uint64_t                           (   1)         <<        i                       )       &                                 x)!=        0; }static inline                                       constexpr  uint64_t                     prefix(int                 i)    noexcept             { 
                                        return                            (i  >=         B         )                       ?       ~                            uint64_t    (0):( (uint64_t (1                                                )         <<i                  )    -uint64_t                  (1   ));}    static inline  
                                       constexpr                           uint64_t      suffix    (                      int     i                         )  noexcept { return     ~prefix(                                                B-           i)                          ;}static                inline           constexpr 
                                        uint64_t                            range        (        int                     l       ,                            int       r) noexcept{return                      prefix                        (          r )                                          ^  prefix (l -    1);}    static  
                                          constexpr                       int   popcnt   (        uint64_t                x       )                           /*           */   noexcept{                    return                            __builtin_popcountll                                            (            x )      ; } 
                                          static                          constexpr     int      clz                      (                                uint64_t         x )     noexcept                       {return  __builtin_clzll         (x    );}                                                 static                     
constexpr                                  int                               ctz        (      uint64_t                   x       )                  noexcept       /*      b       */                   {return __builtin_ctzll       (/*      */x  )  ;}     static                                           inline                   
 constexpr                                 int                                block_id  (        int                      i       )                      /*       */ noexcept {return     i  /  B   ;}int      n,m;  std       ::vector   <   uint64_t  >           b;                                        inline            uint64_t 
  submask                                    (                               int  l     ,         int                     r       )                   const      noexcept        {int             bx         =block_id           (l)        ;assert(bx ==block_id    (r)                                        )       ;    return(b [  
      bx]                                     &                                range    (         l                       -     bx                    *B         +  1   ,r      -bx                   *B   +1   ));   }          inline void trim(  )    noexcept {    b.back                               ( )&= prefix(n  %  B  ==0?   
B:n     %B)                                   ;}                               dynamic_bitset     (                      int     n                  ):dynamic_bitset(      n   ,                 false  ){};              dynamic_bitset(   int            n                 ,bool/*          */init          ) :                     n( 
   n)     ,m(                                  (n                               +  B-   1        )                       /       B                ),b     (   m,init?~ uint64_t(             0):           uint64_t       (0         )){ trim              ();       };inline     void set(int     i          , bool          val    )   
     noexcept{assert                            (0                              <=  i and        i                       <       n              );if ( val   )b  [    i/ B] |=(             uint64_t(1       )<<   (i%  B)   );   else  b[                 i/ B]&=~(uint64_t   (1) <<     (    i%B)         );} inline     bool          
       get     (int                              i  )                            const  noexcept {                      assert   (              0   <=i    and   i      <n  )             ;return(b[   i/  B   ]&(   uint64_t   (1             )<<                     (i   %B))        )!=0/**/            ;   }          bit_reference 
       operator[](int                            i)                              {assert         (                       0       <=       i and   i<   n)  ;return     bit_reference     (*        this ,i   )   ;}    bool   operator   [](int   i)                     const  {assert(                   0<=  i                        
            and     i<n                           );                         return   get(i);}                          void  reset     ()noexcept   {   std     ::fill(                b.           begin(       ),   b .end()   ,uint64_t        (0)                                                     )    ;                  }void 
             operator &=(                          const                           dynamic_bitset&   other               )      {    for(int          i =0           ; i             <std              ::    min(m ,   other    .m   );              i++                                                  )b   [i       ]&=other. b  [i] 
                ;if     (m>                        other                           . m)  std::   fill     (b.begin       (       )+other           .m  ,b            .                begin              ()+m    , uint64_t         (   0)             );                                            }  void operator                |=( 
                 const   dynamic_bitset           &other                              ){       for (int     i  =0;i<std::                  min (m,other.            m                );                                          i++   )                    b[i]|=   other                               .    b[    i ]    ; trim(  ) ;} 
                    void operator               ^=   (                             const dynamic_bitset                    &   other){for(int i      =0             ;               i<                                              std                 ::min (m    ,other                              .m    )                          
                        /*z    */;        i++)       b  [                            i  ]   ^=        other     .b[                        i];   trim(             )               ;}                                                void              operator   <<= (                               int    x)                        { 
                          if(     x/**/==0    )return   ;                            if (x      >=n){   reset           (  )    ; return       ;   }          const               int                                                    /*         fix  */s   =/*  */                                 x     / B                         
                            ,d=x                         %                            B  ,r   =B    -d       ;if(d    >  0  /**/)/*        */             {for(   /*             */                                                        int   i/*    t     a    */                                  =    m- 1                      -  
                               s;   i>0;         i--)b[i +s                            ]  /*   oiw    */  =       (b/**/   [        i]/*a     y     jx*//*       */             <<                                                           /*mi   m*/     d/* m*/     )|(                           b[    i                            
                                 -1]    >>r);b/*x         */                           [s   ]=    b[   0]  << /*        */   d             ;}  else             /*             */  {                                                                     for    (     /*  */                         int   i= m                        - 
                                    1-s            ;i>  0                                ;i  --)b   /*   xg*/  [          /*            yq*/  i+                s              ]  =b                                [i/*           d*//**/]/*      */ ;/*   */b [   /*     */                       s]     =  b                          
                                        [0]   ;}std       ::                               fill(  b   .    begin(     )      ,b  . begin    ( )       +s       /*             */  ,                             uint64_t                     /*g*/       /*b     */ (                              0)      ) ;                           
                                           /*o              */trim                          (  );   }void   operator/*   mt     */>>=          (    int        x             ){  if                          (x==                  0)             return;     if  ( x                             >=      n  )                 {  reset  
()                                     ;return                                               ;  }const int  s    =        x/                   B  ,d=         x%             B   ,                                    l=            B-d   ;    if(   d>  0){for   (int        i= s;i<  m -    1; i++  ) b[i- s]= (  b [i]  >> d)|(b    [ 
  /*m  */                            i+  1                                                    ]  <<   l)  ;  b    [ m      -                   1- s           ]             /*  */                                 =b[                m-  /*ifx   */   1]  >>    d              /* k     i     */;   }else                               
    {/*   */                      for  (int                                                   i   =s    ;  i  <   m  ; i   ++                   )  b[         i            /*  */                -s]                                    /*         */   =  b   [ i            /*  k    nh    */]         ;    }                          
std   ::                       fill   (b                                                       .   /*   */  begin  (        )                   +            m             -   s                 , b                                           .end( )  ,uint64_t(         /*u  i   */0     ))  ;        }    bool                       
        operator==(               const                                                      dynamic_bitset      &  other                        )           {              return               ((n                                                 ==  other  .         n)  and  b==    other .   b)  ;     }                    bool  
operator!=          (            const                                                         dynamic_bitset  &other ){ return                  !           (          *this                   ==                                                     other )         ;}dynamic_bitset operator   &    (    const                       
     /*g*/   dynamic_bitset&other            )                                                  {    dynamic_bitset result  ( *                  this        )            ; result                                                        &=other;return result       ;   }     /*      j     */ dynamic_bitset                          
      operator     |                        (                                                const      dynamic_bitset  & other)                 {                     dynamic_bitset                                              result(            *       this)   ;      /*        */ result |=  other    ;                          
return/*    */                             result                                                ;}      dynamic_bitset operator                  ^         (          const    dynamic_bitset                               &other             )  /*       */            /*v */      {  dynamic_bitset/*     */                         
   result(   *                            this                                                    )         ;/*    */ result   ^=                other      ;      return result        ;}dynamic_bitset              operator              >>(int          x)  {dynamic_bitset     result  (    * this       )                        ; 
         result                          >>=                                                       /*         */    x  ;     return              result    ;           }dynamic_bitset               operator<<(int                         x ){  dynamic_bitset result      (         *this)   ;   result                               
        <<= x                         ;return                                                        result    /*k     pl       */                ;        }       dynamic_bitset       operator                    /*     */~             () {             dynamic_bitset result   (*   this  );   for       (                          
        auto&                       v:                                                                  result   .b)    /*       */               v        =          ~                v;   result                    .trim    ();        return   result;}int        count(     )const noexcept{   return    std ::                     
     accumulate                    (b                                .                                    begin    ()    ,b  .   end              ( ),0    ,          [   ]            (  int sum                         ,       uint64_t value           )    { return  sum   +popcnt  (value    ) ;        }  ) ;}int                 
   find_first                     ()                     {int pos=-1;                                         for   (int  bi  =    0;            bi    <m ;          bi  ++           ){  if                              ( b[ bi]==      uint64_t         (   0 ))continue      ;      pos=ctz    ( b     [ bi  ]) +bi*   B;break    ;} 
   return                       pos                       /**/                                                         ;}           int           find_last          ( ) {           int pos                             =-  1     ;for   (int          bi=m-  1 ;  bi  /*   n t       */   >=     0 ;       /*  y    */                 
/*   q*/                       bi                   --){if                                                (b    [        bi          /*          */   ]  ==         uint64_t          (   0                             /*    */) )   continue             ;  pos/*    */   =B -       /*  */      clz       (  b      [bi             ] 
   )-1                       +bi                /**/                                           *        B; break;}        return pos  ;           /*      */        }  template<typename F1                           ,typename            F2         >void range_process /*   y      */  /*      m */       (  int    l                 
,int                        /*               j*/                                               r       ,         F1         block_brute,F2     block_quick          ) {assert        (  0                            /*     y    */         <=            l  and  l<=r   and  r      /*   */      < n        )  ;     int  bl            
                          /*s              a*/                                                 =                  block_id(l)             ,br=block_id   (          r   )          ;if                             (bl     ==   br           )           block_brute   /*     e      p   */      (l ,        r  )      ;  else{          
                        block_brute      (l,                                                   (                      bl                        +1)*B-1)          ; for          (int bi                     =    bl           +1            ;           bi  <  br  ;bi      ++     )    block_quick      (bi);block_brute( br*B    ,r   
);                     /*s             */}                                                     /*               */}                                     void          range_set (int  l                        ,int          r,bool         val             )   {auto     block_brute    =  [ &  ] (        int l        ,               
 int                  /*             */r                                                        )               ->                                         void    {           int   bi                     =block_id       (l               ) ;     uint64_t mask          =     range (     l  -bi         *  B     +  1         , r   
 -                  bi*    B/*      */                                                           +           1 );                                              if(     /*           */                      val     )b [  bi]               |=   mask;    else b           /*          */    [  bi]         &=  ~     mask             ; 
  }               ;auto block_quick=                [                                             &     ]    ( int                                                bi)->         void                     {/*p     g     w*/                 b       [  bi]=(  val          ?        ~   uint64_t( 0          ) /*     j  */              
 :               uint64_t   (   0))                 ;}                                          ;  range_process                                                       /*     */( l                     ,r      , block_brute              ,block_quick    ) ;}           int      count   /*  v */         ( int     l  ,           int 
 r            ){    int      cnt                     =                                              0/*   */;auto                                                      block_brute                   =[&      ]     (int                   l          , int r)           ->       void {  cnt +=           popcnt     (                  
submask     (l,  r))         ;                        }                                                ;auto    block_quick                                            = [  &                      ](int          bi                      )->        void { cnt         +=       popcnt   (   b  [         bi   ]     )  ;           } ; 
               range_process(                        l,                                                          r,                                                    block_brute              ,block_quick )  ;return                 cnt          ;     }           int       find_first  (int           l  ,    int r            ){  
int pos     =-1         ;auto                        block_brute                                         =[&](int l,int                                                 r)                 ->void           {for                        (int         i       =l       ;i        <= r  and  pos ==           -  1     ;i++  )if(   get (i 
      ))pos=          i;}                         ;    auto                                     block_quick            =[&                                             ](               /*l*/             int                         bi)          /*       h i      */        -> void     {  if            (  b     [                   
                    bi                                        ]==uint64_t(0)or/*nep*/        pos!= -   1)                 return                               ;pos/*pd            j*//*               d*/     =                     ctz            (      b  [    bi] )       /* q  m h  p  */             + /*     y  */               
bi*/*           */B;                                 /**/}   ;                       range_process    (l   ,      /* */r      ,block_brute       ,block_quick);                return              /*dj    b  */                   pos             ;      }int find_last      /*  y u    y  */              (  int   l                   
     ,  int                                     r){int                              pos        =     -1    ;   auto     block_brute      =[&](int    l,                int r)->               void{     for(int                    i=             l;      i <=   r;  i++      ) if ( get  (i               )   )   pos  =          i;};  
          /*r*/                            auto                                     block_quick     /*     */   /*          */ =        [       &    ]                 (int              bi/**/      )->void {                   if                       (  b  [    /*      ub  p s */  bi                ]  ==     uint64_t            
       (       /*anxnu      */0))return/**/                                       ;/*    yf*/     pos     =    /*          y j d*/  /*  h       bjc  */             /*i              o*//*     f   */    B  -                   clz              (       b   [ bi   /*      */  ]   )   -                  1   +        bi               
       */*            s*/B                                                     ;};     range_process      (  l,r            ,  block_brute     ,  /*  l            */             block_quick  )  /*     */ ;                  /* a             */       return     pos    /*  r      */                   ;   }    friend               
         std   ::/*       */                                               ostream  &operator<<(          std::                      ostream   &   os ,        const       dynamic_bitset    &bitset      ){                 for  (           int        i =bitset .m     -1  ;  i>=0                      ;   --   i   )          os<<  
std        /*r    ryh       */::                                      bitset      /*m      */<         /**/                       /*  at  ee   q y  */        /*  r     og*/      B/*      s*/ >           (          /*   o*/                /*        */bitset  /*      q  */ .                          b   [    i   ]                
   /*        *//*   x*/         /*e*/                             /*wtc        */)   ;   os          <<                           '\n'     /*   o a          */ ; return                  os               ;        /*g  t*/   } }            ;           }              /* i  x   f */                    /*  c    r  */                
