template<typename T,const int B>class bitset_chan{public:using T_T=T;static_assert(sizeof(T)*8==  B,                                                            "check block width");static_assert(std::         
is_same<T,uint64_t>::value,"modify popcnt(), ctz(), clz()");public:static/*ej*/inline   constexpr                                                               bool   on( int  i,T x)noexcept{return((T     (   
1)<<i)&x)!=0;}static inline constexpr T prefix(int/**/i)noexcept{return(i>=B)?~T(0)     :                                                                                       ((T(1)<<i)-T(1));}static  inline 
constexpr T suffix(int/**/i)noexcept{return~prefix(B-i);}static inline/**/constexpr                                                                                  T range (int l,int r)noexcept{return        
prefix(r)^prefix(l-1);}static constexpr int popcnt(T x)noexcept{return __builtin_popcountll                                                                                       ( x);}static constexpr    int  
clz(T x)noexcept{return __builtin_clzll(x);}static constexpr int ctz(T x)noexcept                                         {                                                 return   __builtin_ctzll(x);       } 
static inline constexpr int block_id(int i)noexcept{return i/B;}public:inline                                  T   submask(                                                          int/**/l,int r)const        
noexcept{int bx=block_id(l);assert(bx==block_id(r));return(b[bx]&range(l-bx*B                                    +1,    r-bx                               * B+ 1)  ) ; }    inline   void trim()noexcept     {b 
.back()&=prefix(n%B==0?B:n%B);}public:int n,m;std::vector<T>b;bitset_chan(int                                  n):bitset_chan                                                 (  n,false){};bitset_chan(   int n 
,bool/**/init):n(n),m((n+B-1)/B)/**/,/**//**/b(/**//*d*/m,init?~/**//**/T(0                                   )/*v    up*/                                                              :/**//**/T(/**/0         
)){trim();};inline/**/void/**/set(int/**/i,bool/**/val)noexcept{assert(0<=                               i  and/*    */i<                                                               n);if(val)/**/b[         
i/B]|=(T(1)<<(i%B));/*hxp*/else/**//**//**/b[/**/i//**/B]&=~/*h*//**//**/(                                /**/T/*   m*/(1                          )                                     <<(i/**/%/**/B)         
);}inline/**/bool/**/get(int/**/i)const noexcept{assert(0<=i/**/and/**/i<  n                            );return    (b[i/                          B]                                    &(T(1/**/)/*g*/         
<<(i%B)))!=0;}void/*drm*/reset()noexcept{std::fill(b.begin(),b./**/end()   ,                          /**//**//*   *//**/                          T(                                     0/**/)/**//**/         
);}void/*g*/operator&=(const/**/bitset_chan&other){for(int/**/i=/**/0;i <                              std::/*i    i*/min                          (m,                                    other.m);i++)b   [     
i]&=other.b[i];if(m>other.m)std::fill(b.begin()+other/**/./**/m,/*bt*/b                            /**/.begin/*     ec*/                           ()+                                     /*s*//**//**/         
m,T(0));}void operator|=(const bitset_chan&other){for(int i=0;i<std::min                          (m,other.m);i   ++)b[i                          ]|=other                            .b[i];trim();}void operator
^=(const/*ywv*/bitset_chan&other){for(int/**/i=0;i<std::min(m,other.m)                           /**/;i++/**//*   *//*v*/                         /*i*/                                     )b[i]^=other         
.b[i];trim();}void/**/operator<<=(int/**//**/x)/**//**/{if(/**/x==/**/                       0) return;if(x/**/   >=/**/n                             )                                     {reset()/**/         
;return;}const/*rt*/int/**/s=x/B,d=x%B,r/**/=B-d;/*b*/if/**/(d>0)/**/                         {   /*t*/for(/*m*/  int/**/                        /*cx*/                                      i/**//**/=m         
-1-s;i>0;i--)b[i/**/+s/**/]/**/=/**/(b/**/[/**//**//**/i]/*fl*/<</**/                                    d)/*w*/  /**//**/ |                     (b[i/**/                                    -/*i*/1]>>r         
);b[s]=b[0]<<d;}else/**/{for/**/(/**/int/**/i=/*wnfb*/m/*k*//*u*//**/                        /**/            -1-s  ;i>/**/  0            ;       i/*g*/--                                   ) b[/*yhcg*/         
i+s]=b[i];b[s]=b[0/*jzs*//**//**/]/*v*//**//*y*//**/;}std::/**/fill(                        /**/        b      /*m */.begin ()           ,        b.begin                                   (  )+/*ovd*/         
s,T(0));trim();}void/**/operator>>=(int/**/x){if(x==0)return;if/*f*/                      /**/(x                >=/**//*g*//**/n         /*      */){reset                                  /* cq*/(/**/         
);return;}const/**/int/**/s=x/B,d=x%/**/B,l=B-d;/**/if/**/(/**/d/**/                      >0){/*t*/for/*w     cd*//**//*u*/(int/**/       /* k   gan*/i=/*   */                             s/*fly*//**/         
;i<m-/*zf*/1/**/;i++)b/**//*a*/[i/*d*/-/**//**/s/**/]=/**/(/**//**/                       b[i]>>/*o*/d)|(/**/b/**//**/[/**//*l*//**//*g*/i/**/               +1                             ]<< l);b/**/         
/*fra*/[/**/m-1-/**/s]=b/**/[m-1/**//**/]>>d;}/*bs*/else/**/for/**/          (             /**/int/**/i/**/=s;i<m;/**//**/i++)b[/**//**/i                                                    /* */-s/**/         
]=b[i];std::fill(b.begin()/*gfd*/+m-s,/**/b.end/**/(/**/),/**/T/**/          (              0)/**/);}bool/**/operator/**//**//**//**/==/*               */                                   /*l *//**/(         
const/**/bitset_chan&other){return((n==other.n)and/**/b==other.b);}         bool          operator!=(const bitset_chan&other){return!(*this==other     );}bitset_chan                        operator& (         
const bitset_chan&other){bitset_chan result(*this);result&=other;return                   result;}bitset_chan operator|(const bitset_chan&other){bitset_chan                                result(*this      )  
;result|=other;return result;}bitset_chan operator^(const bitset_chan                    & other){bitset_chan result(*this);result^=other;return result;}bitset_chan                         operator>>          
(int/**/x){bitset_chan/**/result(*this);result>>=x;return result;                          }bitset_chan/*muo*/operator<<(int/**/x){bitset_chan/**/result(*this)                              ; result<<=         
/**//*nj*/x;return/**/result/**/;}bitset_chan/**/operator/**//**/                       ~ ( ){bitset_chan/**/result(*this);for(auto&v:result)v=~v;result.trim                                (/*i*/)/**/         
;return result;}int count()const noexcept{return std::accumulate                        ( b.begin(),b.end(),0,[](int sum,T value){return sum+popcnt(value);}     )               ;}int   find_first(){int  pos   
/*py*//**/=-/**/1/*g*//**//**/;/**/for(int/*x*/bi=0/**/;bi</**/m                         ; bi++){if(/**/b[bi/**/]/**/==/*ub*/T(0/*j*/))continue;pos=/**//**/                                  /*xjx*/ctz         
(b[bi])+bi*B;break;}return/*n*/pos;}int/*b*//*k*/find_last/*r*/                          ( /**/){/**/int/**//*c*/pos=/*cx*/-/**//*b*//*v*/1;for(int/**/bi/*    */                             =m-/*fbu*/         
1;bi>=0;bi--){if(/*j*/b[bi]/**/==T/**/(/**/0)/**/)continue/**/                             /*o*//*y*/;pos/**//**//**/=/**/B/**//**/-clz/**/(b[bi]/**/)/*r  ll*/                               -/*a*//**/         
1+bi*B;break;}return/*di*/pos;}void/*e*/range_process(int/**/l ,                            int/**/r,auto/**/block_brute,auto/**/block_quick){assert(/**/0<=l                                 and/*ry*/l         
<=r/**/and/**/r<n);int/**/bl=block_id(l),/**/br=block_id/**/( r)                              ;if/*eq*/(/**/bl/**/==/**/br)/*n*/block_brute/**//**/(/* */                                      l,r);/**/         
else{block_brute(l,(bl+1)*B-1);for(/*tm*/int/**/bi=/**/bl+/* */                                 1/*j*//**/;bi/**/</*j*/br;bi/**/++/*d*/)block_quick                                         (  /*ulg*/bi         
);block_brute(br*B,r);}}void range_set(int l,int r,bool val){auto                                 block_brute=[&](int l,int r)->void{int bi=block_id                                  (   l); T mask=range    (l 
-bi*B+1,r-bi*B+1);if(val)b[bi]|=/*gb*//*ofr*/mask/**/;/**/else                                  /*g oks*//**//**/b/**/[bi]/**//**//*qe*/&=/**/                                              /*  */ ~mask         
;};auto/**/block_quick=[&](/**/int/**/bi)->void{b/**/[/**/bi]                                   =/*hs  i*/(val?~/*l*/T(0/**/):T/*d*/(0/**/                                                  )/*  s ap*/)         
;};range_process(l,r,block_brute,block_quick);}int/*v*/count(                                   int/**/l  ,int/**/r){int cnt=0;auto                                                          block_brute     =[& 
](int/*a*/l,int/**/r)->void{cnt+=popcnt(submask(l,r));};auto                                    block_quick   =[&](int/**/                                                                   bi)   /*b*/         
->void{cnt+=popcnt(b[bi]);};range_process(l,r,block_brute ,                                    block_quick);return                cnt                                                ;}int find_first(int  l ,   
int r){int pos=-1;auto block_brute=[&](int l,int r)->void{                                      for(int/**/i=l;i<=    r  and  pos==                                                     -1;i  ++)if(get(   i  )) 
pos=i;};auto/*k*/block_quick=[&](int/**/bi)->void{if(b[bi]                                      ==/*j*/T(0)/**//*m*/or/**/pos!=/**/                                                           /*   mdd*/         
-1)return;pos=ctz(b[bi])+bi*B;};range_process(l,r,block_brute                                ,block_quick);return pos;}int find_last                   (                             int  l, int r) {int  pos= - 
1;auto/*fb*/block_brute=[&](int/**/l,int/**/r)->void{for                                       (int/*c*/i=l;/**/i/**/<=/*n*/r/*ybk*/     ;             i                                          /**/++         
)if(get(i))pos=i;};auto/*x*/block_quick=/**//**//**//**/                                      /*wgd*/[/**/&](int/**/bi)->/**/void/**/    /*            */                                       { if (b[         
bi]==T(0))return;pos=B-clz(b[bi])-1+bi*B;};range_process                              (l, r ,block_brute,block_quick);return pos;}friend  std       ::ostream                                  &operator <<( std 
::ostream&os,const/**/bitset_chan&bitset)/**/{for(/**/                                 /*   by*//**//**/int/**//**//**//**/i=bitset./**/m/**/-      1/*n*/;/**/                                   /* */i         
>=0;--i)os<<std::bitset<B>(bitset.b[i]);os<<'\n';return                               os;}   };using/**/bitset_chan64=bitset_chan<uint64_t,bit_width(uint64_t/*             */( ))/**/>;          /* f*/         
/*ssk*//*lqe*//**//*vjm*//**//**//*e*//*h*//**//*ny        xq*/  /*y v*/               /*v   wek*//*pq*//**//*cm*//*r*//**//*ilp*//*f*//*e*//* aen*//*d*//*g*/              /*g *//**//**//*         b*/         
